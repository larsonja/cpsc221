[3]
(a)

// Sort an array A of 0’s and 1’s so the 0’s come before the 1’s
// using swapping. The size of the array is n.
int bitsort(int *A, int n) {
int i=0;
int j=n-1;
while( i != j) {
	if( A[i] == 0 ) {
		i++;
	} else if( A[j] == 1) {
		j--;
	} else {
		std::swap( A[i], A[j] );
		}
	}
return j;
}

(b)
Invariant: 0 <= i+j <= (n-1)+(n-1)
Proof: The iteration of the loop will always fall between the value of the size of
the (array - 1) all the way to the size of the ((array - 1) * 2). Given that
i starts at 0 and j starts at n-1, and that i increments when it finds a 0 and that
j decrements when it finds a 1. 

The largest case will be where the array is full of zeros. The iteration of i and j
will start with i = 0 and j = n-1 ( loop invariant held since
i + j >= 0) both i and j will get to the point where i = n-1 and j = n-1 (loop
invariant held since i + j <= 2(n-1)).

The smallest case is when you have a full array of 1s. The values for i and j will
start at 0 and n-1 respectively (where the loop invariant is held since n-1 is 
greater than 0 and smaller than 2(n-1)), and iterate down until i is still at 0 
and j will be equal to 0. Thus the loop invariant is upheld since i+j = 0 
as required.

